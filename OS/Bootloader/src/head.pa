/* Head (Stage 2)
 *
 * Author:   Andr√© Morales 
 * Version:  0.7.0
 * Creation: 02/01/2021
 * Modified: 05/05/2023
 */

;                # Memory Map #
; -- [0x 500 -  ...  ] Where Stage 3 file will be loaded
; -- [0x 700 -  ...  ] Where Stage 3 code begins
; -- [0x3000 -  ...  ] FAT16 Cluster Buffer
; -- [0x6000 -  ...  ] Stage 2 (Us)
; -- [0x7C00 - 0x7DFF] Our VBR still loaded
; -- [0x7E00 - 0x7FFF] Stack

[BITS 16]
[CPU 8086]
[ORG 0x6000]

; How many sectors this stage takes up
%define SECTORS 7
#define FATX_DEBUG 1
#define CONSOLE_MIRROR_TO_SERIAL 1

; Include a few macro definition files
#include "version.pah"
#include <common/console.pah>
#include <common/serial.pah>
SECTION .text vstart=0x6000

; Stores in the file our signature and sector count which
; then are used by Stage 1 to indentify and load us.
db 'Xt'
dw SECTORS  

start: {
	; Clear segments
	xor ax, ax
	mov ds, ax
	mov es, ax
	
	; Get beginning sector pushed by boot_head
	pop word [FATFS.beginningSct]      
	pop word [FATFS.beginningSct + 2]
	
	; Setup stack
	mov ss, ax
	mov sp, 0x7FF0

	; Configure free interrupt 30h to halt the system if we need
	mov word [0x30 * 4 + 0], Halt ; Setup interrupt 0x30 to Halt
	mov word [0x30 * 4 + 2], 0
	
	; Store drive number
	mov [Drive.id], dl
	
	; Print header
	Print(."\N         ZkOS Bootloader v$#VERSION#")
	
	; Initialize serial
	call Serial.init	
	
	; Configure a buffer region and temporary storage to process the file system
	mov word [Drive.bufferPtr], 0x0500
	mov word [FATFS.clusterBuffer], 0x2000
	
	call InitDrive
	call InitFileSystem
	
	Print(."\NPress any key to load BSTRAP.BIN.")
	call WaitKey
	call Load_LdrHeadBin

	; Copy all Drive variables to the pointer stored in Stage 3.
	mov si, Drive
	mov di, [0x702]
	mov cx, Drive.vars_end - Drive
	rep movsb 
	
	; Copy all FATFS variables to the pointer stored in Stage 3.
	mov si, FATFS
	mov di, [0x704]
	mov cx, FATFS.vars_end - FATFS
	rep movsb 
	
	Print(."OK.")
	
	cmp word [0x500], 'Zk' | je .jump
	Print(."\NInvalid signature")
	int 0x30

; Jump to Stage 3.
.jump:
	jmp 0x700
}

; -- Load XTOS/BSTRAP.BIN
Load_LdrHeadBin: {
	mov ax, ."ZKOS       "
	push ax
	call FATFS.FindFileInRootDir
	
	Serial.Print(."\Nfound in cl: ")
	Serial.PrintHexNum ax

	mov si, ."ZKOS/BSTRAP  BIN"
	call FATFS.FindFile
	Print(."\NFound.")
	
	mov word [Drive.bufferPtr], 0x500
	
	push ax
	call FATFS.ReadClusterChain
	
	Print(." Loaded.\N")
ret }

FileNotFoundOnDir: {
	push si
	Print(."\NFile '")
	;mov si, [FATFS.filePathPtr]
	pop si
	call print
	
	Print(."' not found on directory.")
	int 30h
}


Halt: {
	Print(."\NSystem halted.")
	cli | hlt
}

InitFileSystem: {
	Print(."\N--- [Boot partition properties] ---")
	
	push ds 
	
	push ds | pop es
	xor ax, ax | mov ds, ax

	mov ax, 0x7C00 | push ax
	call FATFS.Initialize
	
	pop ds	
	
	Print(."\NLabel: ")
	Print(FATFS.label)
	
	Print(."\NBits: ")
	xor ah, ah
	mov al, [FATFS.clusterBits]
	call printDecNum
	
	Print(."\NBeginning: 0x")
	PrintHexNum word [FATFS.beginningSct + 2]
	Putch(':')
	PrintHexNum word [FATFS.beginningSct]
	
	Print(."\NFAT: 0x")
	PrintHexNum word [FATFS.fatSct + 2]
	Putch(':')
	PrintHexNum word [FATFS.fatSct]
	
	Print(."\NRoot Dir: 0x")
	PrintHexNum word [FATFS.rootDirSct + 2]
	Putch(':')
	PrintHexNum word [FATFS.rootDirSct]

	Print(."\NData Area: 0x")
	PrintHexNum word [FATFS.dataAreaSct + 2]
	Putch(':')
	PrintHexNum word [FATFS.dataAreaSct]
	
	Print(."\NReserved Lg. Sectors: ")
	PrintDecNum [FATFS.reservedLogicalSectors] 
	
	Print(."\NBytes per Logical Sector: ")
	PrintDecNum [FATFS.bytesPerLogicalSector] 
	Print(."\NLogical Sectors per Cluster: ")
	PrintDecNum [FATFS.logicalSectorsPerCluster] 
	Print(."\NBytes per Cluster: ")
	PrintDecNum [FATFS.bytesPerCluster] 
	Print(."\NLogical Sectors per FAT: ")
	PrintDecNum [FATFS.logicalSectorsPerFAT] 
	Print(."\NFATs: ")
	PrintDecNum [FATFS.fats]
	Print(."\NRoot directory entries: ")
	PrintDecNum [FATFS.rootDirectoryEntries] 
	Print(."\NDirectory entries per cluster: ")
	PrintDecNum [FATFS.directoryEntriesPerCluster] 
ret }

InitDrive: {	
	call Drive.Init
	call Drive.CHS.GetProperties
	call Drive.LBA.GetProperties

	Print(."\N--- [Geometries of drive: ")
	xor ah, ah
	mov al, [Drive.id]
	PrintHexNum(ax)
	Print(."] ---")
	
	Print(."\NCHS (AH = 02h)")
	Print(."\N  Bytes per Sector: ")
	PrintDecNum [Drive.CHS.bytesPerSector]
	
	Print(."\N  Sectors per Track: ")
	xor ah, ah
	mov al, [Drive.CHS.sectorsPerTrack]
	call printDecNum

	Print(."\N  Heads Per Cylinder: ")
	PrintDecNum [Drive.CHS.headsPerCylinder]
	
	Print(."\N  Cylinders: ")
	PrintDecNum [Drive.CHS.cylinders]
	
	Print(."\NLBA (AH = 48h)")
	
	mov al, [Drive.LBA.available]
	test al, al | jz .printLBAProps
	cmp al, 1   | je .noDriveLBA
	Print(."\N  The BIOS doesn't support LBA.")
	jmp .End
	
	.noDriveLBA:
	Print(."\N  The drive doesn't support LBA.")
	jmp .End
	
	.printLBAProps:
	Print(."\N  Bytes per Sector: ")
	PrintDecNum [Drive.LBA.bytesPerSector]
		
	.End:
ret }

; Include defitions of a few commonly used functions
#include <common/console.pa>
#include <common/drive.pa>
#include <common/fat1x.pa>
#include <common/serial.pa>

@rodata:
times (512 * SECTORS)-($-$$) db 0x90 ; Round to 1kb.

; --------- Variable space ---------
SECTION .bss
@data:
